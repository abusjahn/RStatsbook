{
  "hash": "29d9dcd5bd0af1b446f5ef57a58036cf",
  "result": {
    "markdown": "# Syntax rules / basic things to know about R\n\n## Script preparation / basic setup\n\nAt the beginning of (almost) every script we define packages to be used. This could be done by either\n\n-   checking if packages needed are installed and otherwise do so, followed by function `library(packagename)`\n\nOR\n\n-   simplifying this using function p_load() from package pacman; if you want to create fool-proof scripts, check for pacman and install if needed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(LANG=\"en_EN.UTF-8\") # to get errors/warnings in English\nif(!requireNamespace(\"pacman\",quietly = TRUE)){\n  install.packages(\"pacman\")\n}\npacman::p_load(\n  conflicted, # tests/solutions for name conflicts\n  tidyverse, # metapackage \n  wrappedtools, # my own tools package\n  randomNames # used to create pseudo names\n  )\n```\n:::\n\n\n## Numeric operations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### simple calculations ####\n2+5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\n3*5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n\n```{.r .cell-code}\n15/3 #not 15:3!!, would create vector 15,14,13 ... 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n3^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\n9^0.5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n10%%3 #modulo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n## Variables\n\n### Variable names\n\nNaming things is harder than you may expect. Try to be verbose and consistent in language and style. Commonly used are snake_case_style and CamelCaseStyle.\n\nDecide about computer-friendly (syntactical) or human-friendly names, illegal names can be used inside backticks: \\`measure \\[unit\\]\\`. My preference is syntactical for script variables and humane for data variables, e.g. column names, print labels etc.\n\nThere are rules for valid syntactical names:\n\n-   UPPERCASE and lowercase are distinguished\n\n-   start with letter or symbols as **.** **\\_** , but not with a number\n\n-   no mathematical symbols or brackets allowed\n\nTo store some value into a variable, use the assignment operator **\\<-** ; while it possible to use **=** or **-\\>** , this is rather unusual. Assignments are silent, so either a call of the variable, or `print()` / `cat()` function are needed to inspect. Alternatively, put brackets around assignment: (varname \\<- content).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Variable names ####\ntest <- 1\ntest1 <- 1\n# 1test <- 2 # wrong, would result in error\n`1test` <- 2 # this would be possible\ntest_1 <- 5\ntest.1 <- 2\n`test-1` <- 6\n`test(1)` <- 5\nTest <- 'bla'\nHereAreFilteredData <- '' #CamelCase\nhere_are_filtered_data <- \"test\" #snake_case\n`Weight [kg]` <- 67 \n```\n:::\n\n\n### Basic classes of data\n\nR is 'guessing' the suitable type of data from input. This should be checked after e.g. importing data! If elements of different classes are found, the more inclusive is used. There are functions to change / force a type if needed.\n\nThe **`class()`** function returns the class of an object, which determines how it behaves with respect to functions like **`print()`**. The class of an object can be changed by using generic functions and methods.\n\nThe **`typeof()`** function returns the basic data type of an object, which determines how it is stored in memory. The basic data type of an object cannot be changed.\n\nThe **`str()`** function shows class and examples of an object.\n\n#### Guessed classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfloat_num <- 123.456\nclass(float_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(float_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nint_num <- 123L # L specifies integer, guessing requires more values\nclass(int_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(int_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ninteger(length = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0\n```\n:::\n\n```{.r .cell-code}\nresult<-9^(1/2)\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ncat(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n\n```{.r .cell-code}\nchar_var <- \"some words\"\nclass(char_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(char_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ncharacter(length = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\" \"\" \"\" \"\" \"\"\n```\n:::\n\n```{.r .cell-code}\nlogical_var <- TRUE # can be abbreviated to T \nlogical_var2 <- FALSE # or F, seen as bad style\nclass(logical_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(logical_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\nlogical(length = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n# logicals usualy are defined by conditions:\nint_num < float_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# all numbers are true but 0\nas.logical(c(0,1,5,-7.45678)) # c() combines values into a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n\nFactor: categorical variables with limited set of distinct values, internally stored as integers. Everything intended to group subjects or representing categories should be stored as factor.\\\nPackage forcats provides nice tools for factors!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor_var <- factor(c(\"m\",\"m\",\"f\",\"m\",\"f\",\"f\",\"?\"))\nfactor_var\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] m m f m f f ?\nLevels: ? f m\n```\n:::\n\n```{.r .cell-code}\nclass(factor_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(factor_var) # that is why factors can be called enumerated type\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\n# factor definition can reorder, rename, and drop levels:\nfactor_var2 <- factor(c(\"m\",\"m\",\"f\",\"m\",\"f\",\"f\",\"?\"),\n                     levels=c(\"m\",\"f\"),\n                     labels=c(\"male\",\"female\"))\nfactor_var2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] male   male   female male   female female <NA>  \nLevels: male female\n```\n:::\n:::\n\n\nDates / Time:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(date_var <- Sys.Date())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-07-17\"\n```\n:::\n\n```{.r .cell-code}\nclass(date_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Date\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(date_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nclass(Sys.time())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"POSIXct\" \"POSIXt\" \n```\n:::\n:::\n\n\nMixed classes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest2 <- c(1,2,'a','b')\nclass(test2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ntest2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"a\" \"b\"\n```\n:::\n:::\n\n\n#### Forcing / casting classes\n\nCasting functions usually start with `as_` , when creating variables filled with NA, use casting functions or specific variants of NA to force type!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(test<-c(1,2,3,'a','b','c')) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"3\" \"a\" \"b\" \"c\"\n```\n:::\n\n```{.r .cell-code}\n(test_n<-as.numeric(test))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  2  3 NA NA NA\n```\n:::\n\n```{.r .cell-code}\nas.numeric(factor_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3 2 3 2 2 1\n```\n:::\n\n```{.r .cell-code}\nas.character(10:19)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" \"16\" \"17\" \"18\" \"19\"\n```\n:::\n\n```{.r .cell-code}\n# NAs\nclass(NA_real_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(NA_integer_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nclass(NA_character_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(NA_Date_) # from package lubridate\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Date\"\n```\n:::\n:::\n\n\n### Indexing variables\n\nThe most general kind of indexing is by position, starting with 1. Negative numbers result in exclusion of position(s). Position indices are provided within square brackets. The index can (and usually will) be a variable instead of hard coded numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(numbers1<-c(5,3,6,8,2,1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 3 6 8 2 1\n```\n:::\n\n```{.r .cell-code}\nnumbers1[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nnumbers1[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 3 6\n```\n:::\n\n```{.r .cell-code}\nnumbers1[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 6 8 2 1\n```\n:::\n\n```{.r .cell-code}\nnumbers2 <- 1:3\nnumbers1[numbers2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 3 6\n```\n:::\n:::\n\n\nTo get first or last entries, head() and tail() can be used. By default 6 entries are returned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(x=numbers1,n = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nhead(x = numbers1, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 3 6\n```\n:::\n:::\n\n\n### Usage of variables\n\nVariables are like placeholders for their content, so that you don't have to remember where you left things. Operations on variables are operations on their content. Changing the content of a variable does not automatically save those changes back to the variable, this needs to be done explicitly!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers1+100 # not stored anywhere, just printed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 105 103 106 108 102 101\n```\n:::\n\n```{.r .cell-code}\nnumbers1+numbers2 # why does this even work?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6 5 9 9 4 4\n```\n:::\n:::\n\n\nWhen combining variables of different length, the short one is recycled, so the numbers2 is added to the first 3 elements of numbers2, then is reused and added to the remaining 3 elements. If the length of the longer is not a multiple of the shorter, there will be a warning.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2,4,6,8)+1 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 5 7 9\n```\n:::\n\n```{.r .cell-code}\nc(2,4,6,8)+c(1,2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  6  7 10\n```\n:::\n\n```{.r .cell-code}\nc(2,4,6,8)+c(1,2,3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in c(2, 4, 6, 8) + c(1, 2, 3): longer object length is not a multiple\nof shorter object length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 6 9 9\n```\n:::\n:::\n\n\n## Functions\n\n### Function useage\n\nFunctions have the same naming rules as variables, but the name is always followed by opening/closing round brackets, within those brackets function parameters/arguments can be specified to provide input or control behavior:\n\nFunctionName(parameter1=x1,parameter2=x2,x3,...)\n\nMost functions have named arguments, those argument names may be omitted as long as parameter values are supplied in the defined order. Arguments may have predefined default values, see help! Some functions like `c()` use unnamed arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc('my','name') # unnamed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"my\"   \"name\"\n```\n:::\n\n```{.r .cell-code}\n# ?mean\nmean(x = c(3,5,7,NA)) #using default parameters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nmean(x = c(3,5,7,NA),na.rm = TRUE) #overriding default parameter\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nmean(na.rm = TRUE, x=c(3,5,7,NA)) # changed order of arguments\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nmean(c(3,5,7,NA), na.rm = TRUE) # name of 1st argument omitted\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nsd(c(3,5,7,NA), na.rm = TRUE) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\n# same logic as mean, partially the same arguments\nmedian(1:100, TRUE) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50.5\n```\n:::\n\n```{.r .cell-code}\n# omitting arguments influences readability of a function, careful!\n```\n:::\n\n\n### Functions combined\n\nFunctions often just solve one problem or task, so usually we need to combine them. This can be done by nesting or piping. Piping makes reading/understanding scripts easier, as it shows order of functions:\n\n![Piping functions](Graphs/piping_complete.jpg){fig-pos=\"h\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# functions may be nested:\nfloor(\n  as.numeric(\n    Sys.Date() -\n      as.Date('1985/12/10'))/\n    365.25)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 37\n```\n:::\n\n```{.r .cell-code}\n# or (usually better) piped:\nmtcars |>\n  mutate(am=factor(am))  |>\n  filter(vs==1) |>\n  group_by(am) |>\n  summarize(across(.cols = c(wt, mpg, qsec, disp),\n                   .fns = mean))  |>\n  pivot_longer(cols = -am, names_to = 'Measure')  |>\n  pivot_wider(id_cols = Measure, names_from = am,\n              values_from = value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 3\n  Measure    `0`   `1`\n  <chr>    <dbl> <dbl>\n1 wt        3.19  2.03\n2 mpg      20.7  28.4 \n3 qsec     20.0  18.7 \n4 disp    175.   89.8 \n```\n:::\n:::\n\n\nIf a sequence of functions is used often, combining them into a new function is advisable, e.g. this combination of descriptive and test statistics:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# can be combined into higher order functions:\ncompare2numvars(data = mtcars,\n                dep_vars = c('mpg','wt','qsec'),\n                indep_var = 'am',\n                add_n = TRUE,\n                gaussian = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 5\n  Variable desc_all          `am 0`            `am 1`            p    \n  <fct>    <chr>             <chr>             <chr>             <chr>\n1 mpg      20 ± 6  [n=32]    17 ± 4  [n=19]    24 ± 6  [n=13]    0.001\n2 wt       3.2 ± 1.0  [n=32] 3.8 ± 0.8  [n=19] 2.4 ± 0.6  [n=13] 0.001\n3 qsec     18 ± 2  [n=32]    18 ± 2  [n=19]    17 ± 2  [n=13]    0.206\n```\n:::\n:::\n\n\n### Writing functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#FunctionName<-function(parameters...){definition}\nmarkSign<-function(SignIn) {\n  SignIn <- as.numeric(SignIn)\n  if(is.na(SignIn)){\n    SignOut<-'wrong input, stupido!'\n  } else {\n    # if (!is.na(SignIn)) {\n    SignOut<-'n.s.'\n    if (SignIn<=0.1) {SignOut<-'+'}\n    if (SignIn<=0.05) {SignOut<-'*'}\n    if (SignIn<=0.01) {SignOut<-'**'}\n    if (SignIn<=0.001) {SignOut<-'***'}\n  }\n  return(SignOut)\n}\n\nmarkSign(SignIn=0.035)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"*\"\n```\n:::\n\n```{.r .cell-code}\nmarkSign(SignIn=\"0.35\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"n.s.\"\n```\n:::\n\n```{.r .cell-code}\nmarkSign(SignIn = 'p=3,5%')   #wrong parameter\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in markSign(SignIn = \"p=3,5%\"): NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"wrong input, stupido!\"\n```\n:::\n\n```{.r .cell-code}\nMymean<-function(werte)\n{\n  return(base::mean(werte,na.rm=T))\n}\n# source('myfunctions.R')\n```\n:::\n\n\n## More complex data types, created by functions\n\n### Matrix\n\nA matrix is a 2-dimensional data structure, where all elements are of the same class.\n\n#### Creation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy1.Matrix<-\n  matrix(data=1:12,\n         # nrow=4, # this is not needed, can be derived from data\n         ncol=3,\n         byrow=T, # date are put into row 1 first\n         dimnames=list(paste0('row',1:4),\n                       paste0('col',1:3)))\nprint(my1.Matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     col1 col2 col3\nrow1    1    2    3\nrow2    4    5    6\nrow3    7    8    9\nrow4   10   11   12\n```\n:::\n\n```{.r .cell-code}\ndata <- 1:100\nnrow <- 20\nmatrix(data=data,\n       nrow=nrow,\n       byrow=F, # data are put into column 1 first\n       dimnames=list(paste0('row',1:nrow),\n                     paste0('col',1:(length(data)/nrow)))) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     col1 col2 col3 col4 col5\nrow1    1   21   41   61   81\nrow2    2   22   42   62   82\nrow3    3   23   43   63   83\nrow4    4   24   44   64   84\nrow5    5   25   45   65   85\nrow6    6   26   46   66   86\n```\n:::\n\n```{.r .cell-code}\nmdat <- matrix(c(1,2,3, 11,12,13),\n               nrow = 2, ncol=3) #byrow=FALSE, specified but default\nmdat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3   12\n[2,]    2   11   13\n```\n:::\n:::\n\n\n#### Indexing\n\nAddressing a matrix is done with \\[row_index, column_index\\]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy1.Matrix[2,3] # Index:[row,column]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nmy1.Matrix[2,] # all columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncol1 col2 col3 \n   4    5    6 \n```\n:::\n\n```{.r .cell-code}\nmy1.Matrix[,2] # all rows\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrow1 row2 row3 row4 \n   2    5    8   11 \n```\n:::\n\n```{.r .cell-code}\nmy1.Matrix[c(1,3),-2] # exclude column 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     col1 col3\nrow1    1    3\nrow3    7    9\n```\n:::\n\n```{.r .cell-code}\nmy1.Matrix[1,1]<-NA # Index can be used for writing as well\n```\n:::\n\n\n### Data frame\n\nA data frame has 2 dimensions, it can handle various data types (1 per columns). This structure is rather superseded by tibbles (see below).\n\n#### Creation\n\nData frames are defined by creating and filling columns, functions can be used (and piped) to create content.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatientN<-15\n(myTable<-data.frame(\n  patientCode=paste0('pat',1:patientN),\n  Var1=1, # gets recycled\n  Var2=NA_Date_)) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  patientCode Var1 Var2\n1        pat1    1 <NA>\n2        pat2    1 <NA>\n3        pat3    1 <NA>\n4        pat4    1 <NA>\n5        pat5    1 <NA>\n6        pat6    1 <NA>\n```\n:::\n\n```{.r .cell-code}\nstr(myTable)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t15 obs. of  3 variables:\n $ patientCode: chr  \"pat1\" \"pat2\" \"pat3\" \"pat4\" ...\n $ Var1       : num  1 1 1 1 1 1 1 1 1 1 ...\n $ Var2       : Date, format: NA NA ...\n```\n:::\n\n```{.r .cell-code}\nset.seed(101)\nmyTable<-data.frame(\n  patientCode=paste0('pat',1:patientN),\n  Age=runif(n=patientN,min=18,max=65)  |>  floor(),\n  Sex=factor(rep(x=NA,times=patientN),\n             levels=c('m','f')),\n  sysRR=round(rnorm(n=patientN,mean=140,sd=10)))\nhead(myTable)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  patientCode Age  Sex sysRR\n1        pat1  35 <NA>   142\n2        pat2  20 <NA>   132\n3        pat3  51 <NA>   122\n4        pat4  48 <NA>   157\n5        pat5  29 <NA>   144\n6        pat6  32 <NA>   148\n```\n:::\n:::\n\n\n#### Indexing\n\nBeside the numeric index, columns can be addressed by name. This can be done by either dfname\\$colname (for the content of a single column) or dfname\\[,\"colname\"\\] for 1 or more columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyTable[1:5,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pat1\" \"pat2\" \"pat3\" \"pat4\" \"pat5\"\n```\n:::\n\n```{.r .cell-code}\nmyTable$patientCode[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pat1\" \"pat2\" \"pat3\" \"pat4\" \"pat5\"\n```\n:::\n\n```{.r .cell-code}\nmyTable[1:5,\"patientCode\"] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pat1\" \"pat2\" \"pat3\" \"pat4\" \"pat5\"\n```\n:::\n\n```{.r .cell-code}\n# returns vector of values for a single column, df otherwise\nmyTable[\"patientCode\"] # returns df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   patientCode\n1         pat1\n2         pat2\n3         pat3\n4         pat4\n5         pat5\n6         pat6\n7         pat7\n8         pat8\n9         pat9\n10       pat10\n11       pat11\n12       pat12\n13       pat13\n14       pat14\n15       pat15\n```\n:::\n\n```{.r .cell-code}\nspalten<-c('Sex',\"Age\")\nmyTable[1:5,spalten]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Sex Age\n1 <NA>  35\n2 <NA>  20\n3 <NA>  51\n4 <NA>  48\n5 <NA>  29\n```\n:::\n\n```{.r .cell-code}\nmyTable[1:5,c('patientCode','Age')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  patientCode Age\n1        pat1  35\n2        pat2  20\n3        pat3  51\n4        pat4  48\n5        pat5  29\n```\n:::\n\n```{.r .cell-code}\nmyTable[,1]<-paste0('Code',1:patientN) \n```\n:::\n\n\n### Tibble\n\nTibbles are a modern and efficient data structure that extend data frames, providing enhanced features and performance for data manipulation and analysis.\n\n#### Creation\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatientN <- 25\nrawdata <- tibble(\n  PatID=paste('P',1:patientN), # as in  data.frame\n  Sex=sample(x = c('male','female'),  # random generator\n             size = patientN,replace = T,\n             prob = c(.7,.3)),\n  Ethnicity=sample(1:6,patientN,T,c(.01,.01,.05,.03,.75,.15)), \n  # random assignments\n  `Given name`=randomNames(n = patientN,\n                           gender = Sex, \n                           # this is a reference to column Sex\n                           ethnicity = Ethnicity,\n                           which.names = 'first'),\n  `Family name`=randomNames(n = patientN,\n                            ethnicity = Ethnicity,\n                            which.names = 'last'),\n  Treatment=sample(c('Placebo','Verum'),patientN,T),\n  `sysRR (mmHg)`=round(rnorm(n=patientN,mean=140,sd=10))-\n    (Treatment=='Verum')*15,\n  `diaRR (mmHg)`=round(rnorm(n=patientN,mean=80,sd=10))-\n    (Treatment=='Verum')*10,\n  HR=round(rnorm(n=patientN,mean=90,sd=7)))\nrawdata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 9\n   PatID Sex    Ethnicity `Given name` `Family name` Treatment `sysRR (mmHg)`\n   <chr> <chr>      <int> <chr>        <chr>         <chr>              <dbl>\n 1 P 1   male           5 Ian          Roy           Placebo              128\n 2 P 2   male           3 Dametrious   Martin        Placebo              116\n 3 P 3   female         5 Alyxandra    Fisher        Verum                120\n 4 P 4   female         6 Musfira      el-Karimi     Verum                130\n 5 P 5   male           6 Saleel       al-Bey        Placebo              135\n 6 P 6   male           5 Kahner       Melott        Verum                148\n 7 P 7   male           5 Skylar       Burgess       Verum                137\n 8 P 8   male           5 Michael      Harper        Placebo              139\n 9 P 9   female         5 Julia        Tovrea        Placebo              154\n10 P 10  male           4 Eric         Barreras      Verum                113\n# i 15 more rows\n# i 2 more variables: `diaRR (mmHg)` <dbl>, HR <dbl>\n```\n:::\n\n```{.r .cell-code}\ncolnames(rawdata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"PatID\"        \"Sex\"          \"Ethnicity\"    \"Given name\"   \"Family name\" \n[6] \"Treatment\"    \"sysRR (mmHg)\" \"diaRR (mmHg)\" \"HR\"          \n```\n:::\n\n```{.r .cell-code}\ncn() # shortcut from wrappedtools\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"PatID\"        \"Sex\"          \"Ethnicity\"    \"Given name\"   \"Family name\" \n[6] \"Treatment\"    \"sysRR (mmHg)\" \"diaRR (mmHg)\" \"HR\"          \n```\n:::\n\n```{.r .cell-code}\n# example of data management for a tibble, recoding ethnicity:\nrawdata <- rawdata  |>\n  mutate(Ethnicity=factor(\n    Ethnicity,levels = 1:6,\n    labels=\tc(\n      'American Indian or Native Alaskan',\n      'Asian or Pacific Islander',\n      'Black (not Hispanic)',\n      'Hispanic',\n      'White (not Hispanic)',\n      'Middle-Eastern, Arabic')))\n# quick visual inspection\nggplot(rawdata,aes(x = Treatment,y = `sysRR (mmHg)`))+\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](R101_files/figure-pdf/unnamed-chunk-21-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n#### Indexing\n\nThe same rules as for the data frame, but more consistent behavior.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrawdata[1:5,1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n  PatID Sex   \n  <chr> <chr> \n1 P 1   male  \n2 P 2   male  \n3 P 3   female\n4 P 4   female\n5 P 5   male  \n```\n:::\n\n```{.r .cell-code}\nrawdata[,6]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 1\n   Treatment\n   <chr>    \n 1 Placebo  \n 2 Placebo  \n 3 Verum    \n 4 Verum    \n 5 Placebo  \n 6 Verum    \n 7 Verum    \n 8 Placebo  \n 9 Placebo  \n10 Verum    \n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata[6]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 1\n   Treatment\n   <chr>    \n 1 Placebo  \n 2 Placebo  \n 3 Verum    \n 4 Verum    \n 5 Placebo  \n 6 Verum    \n 7 Verum    \n 8 Placebo  \n 9 Placebo  \n10 Verum    \n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata[[6]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Placebo\" \"Placebo\" \"Verum\"   \"Verum\"   \"Placebo\" \"Verum\"   \"Verum\"  \n [8] \"Placebo\" \"Placebo\" \"Verum\"   \"Verum\"   \"Verum\"   \"Verum\"   \"Placebo\"\n[15] \"Verum\"   \"Verum\"   \"Verum\"   \"Placebo\" \"Placebo\" \"Verum\"   \"Placebo\"\n[22] \"Placebo\" \"Placebo\" \"Placebo\" \"Verum\"  \n```\n:::\n\n```{.r .cell-code}\nrawdata$`Family name`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Roy\"            \"Martin\"         \"Fisher\"         \"el-Karimi\"     \n [5] \"al-Bey\"         \"Melott\"         \"Burgess\"        \"Harper\"        \n [9] \"Tovrea\"         \"Barreras\"       \"Klamerus\"       \"al-Satter\"     \n[13] \"al-Sultana\"     \"Yi\"             \"Helm\"           \"Molina-Peinado\"\n[17] \"Spilsted\"       \"Egan\"           \"Thompson\"       \"Schauss\"       \n[21] \"Owens\"          \"Vick\"           \"Reeves\"         \"Chesney\"       \n[25] \"Minnillo\"      \n```\n:::\n:::\n\n\nDifferences in addressing data frames and tibbles:\n\n-   tibble and `[` always returns tibble\n\n-   tibble and `[[` always returns vector\n\n-   data.frame and `[` may return data.frame (if \\>1 column) or vector\n\n-   data.frame and `[[` always returns vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrawdata_df <- as.data.frame(rawdata)\nrawdata[2] #returns Tibble with 1 column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 1\n   Sex   \n   <chr> \n 1 male  \n 2 male  \n 3 female\n 4 female\n 5 male  \n 6 male  \n 7 male  \n 8 male  \n 9 female\n10 male  \n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata[[2]] #returns vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"male\"   \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"male\"  \n [9] \"female\" \"male\"   \"female\" \"male\"   \"male\"   \"male\"   \"male\"   \"female\"\n[17] \"female\" \"male\"   \"female\" \"female\" \"female\" \"male\"   \"male\"   \"female\"\n[25] \"female\"\n```\n:::\n\n```{.r .cell-code}\nrawdata[,2] #returns Tibble with 1 column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 1\n   Sex   \n   <chr> \n 1 male  \n 2 male  \n 3 female\n 4 female\n 5 male  \n 6 male  \n 7 male  \n 8 male  \n 9 female\n10 male  \n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata[,2:3] #returns tibble with 2 columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 2\n   Sex    Ethnicity             \n   <chr>  <fct>                 \n 1 male   White (not Hispanic)  \n 2 male   Black (not Hispanic)  \n 3 female White (not Hispanic)  \n 4 female Middle-Eastern, Arabic\n 5 male   Middle-Eastern, Arabic\n 6 male   White (not Hispanic)  \n 7 male   White (not Hispanic)  \n 8 male   White (not Hispanic)  \n 9 female White (not Hispanic)  \n10 male   Hispanic              \n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata_df[2] #returns DF with 1 column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Sex\n1    male\n2    male\n3  female\n4  female\n5    male\n6    male\n7    male\n8    male\n9  female\n10   male\n11 female\n12   male\n13   male\n14   male\n15   male\n16 female\n17 female\n18   male\n19 female\n20 female\n21 female\n22   male\n23   male\n24 female\n25 female\n```\n:::\n\n```{.r .cell-code}\nrawdata_df[[2]] #returns vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"male\"   \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"male\"  \n [9] \"female\" \"male\"   \"female\" \"male\"   \"male\"   \"male\"   \"male\"   \"female\"\n[17] \"female\" \"male\"   \"female\" \"female\" \"female\" \"male\"   \"male\"   \"female\"\n[25] \"female\"\n```\n:::\n\n```{.r .cell-code}\nrawdata_df[,2] #returns vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"male\"   \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"male\"  \n [9] \"female\" \"male\"   \"female\" \"male\"   \"male\"   \"male\"   \"male\"   \"female\"\n[17] \"female\" \"male\"   \"female\" \"female\" \"female\" \"male\"   \"male\"   \"female\"\n[25] \"female\"\n```\n:::\n\n```{.r .cell-code}\nrawdata_df[,2:3] #returns DF with 2 columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Sex                 Ethnicity\n1    male      White (not Hispanic)\n2    male      Black (not Hispanic)\n3  female      White (not Hispanic)\n4  female    Middle-Eastern, Arabic\n5    male    Middle-Eastern, Arabic\n6    male      White (not Hispanic)\n7    male      White (not Hispanic)\n8    male      White (not Hispanic)\n9  female      White (not Hispanic)\n10   male                  Hispanic\n11 female      White (not Hispanic)\n12   male    Middle-Eastern, Arabic\n13   male    Middle-Eastern, Arabic\n14   male Asian or Pacific Islander\n15   male      White (not Hispanic)\n16 female                  Hispanic\n17 female      White (not Hispanic)\n18   male      White (not Hispanic)\n19 female      White (not Hispanic)\n20 female      White (not Hispanic)\n21 female      White (not Hispanic)\n22   male      Black (not Hispanic)\n23   male      White (not Hispanic)\n24 female      White (not Hispanic)\n25 female      White (not Hispanic)\n```\n:::\n:::\n\n\nThere are specific functions for picking columns or rows, especially useful in pipes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrawdata %>% select(PatID:Ethnicity,`sysRR (mmHg)`:HR)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 6\n   PatID Sex    Ethnicity              `sysRR (mmHg)` `diaRR (mmHg)`    HR\n   <chr> <chr>  <fct>                           <dbl>          <dbl> <dbl>\n 1 P 1   male   White (not Hispanic)              128             87    88\n 2 P 2   male   Black (not Hispanic)              116             72    82\n 3 P 3   female White (not Hispanic)              120             60    93\n 4 P 4   female Middle-Eastern, Arabic            130             76    82\n 5 P 5   male   Middle-Eastern, Arabic            135             60   100\n 6 P 6   male   White (not Hispanic)              148             85    85\n 7 P 7   male   White (not Hispanic)              137             54    98\n 8 P 8   male   White (not Hispanic)              139             95    94\n 9 P 9   female White (not Hispanic)              154             71    83\n10 P 10  male   Hispanic                          113             74    82\n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata %>% select(PatID:Ethnicity,`sysRR (mmHg)`:HR) %>% slice(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 6\n  PatID Sex    Ethnicity              `sysRR (mmHg)` `diaRR (mmHg)`    HR\n  <chr> <chr>  <fct>                           <dbl>          <dbl> <dbl>\n1 P 1   male   White (not Hispanic)              128             87    88\n2 P 2   male   Black (not Hispanic)              116             72    82\n3 P 3   female White (not Hispanic)              120             60    93\n4 P 4   female Middle-Eastern, Arabic            130             76    82\n5 P 5   male   Middle-Eastern, Arabic            135             60   100\n```\n:::\n\n```{.r .cell-code}\nrawdata %>% select(contains('RR',ignore.case = F))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 2\n   `sysRR (mmHg)` `diaRR (mmHg)`\n            <dbl>          <dbl>\n 1            128             87\n 2            116             72\n 3            120             60\n 4            130             76\n 5            135             60\n 6            148             85\n 7            137             54\n 8            139             95\n 9            154             71\n10            113             74\n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata %>% select(ends_with('r'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 1\n      HR\n   <dbl>\n 1    88\n 2    82\n 3    93\n 4    82\n 5   100\n 6    85\n 7    98\n 8    94\n 9    83\n10    82\n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata %>% select(-contains('name'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 7\n   PatID Sex    Ethnicity          Treatment `sysRR (mmHg)` `diaRR (mmHg)`    HR\n   <chr> <chr>  <fct>              <chr>              <dbl>          <dbl> <dbl>\n 1 P 1   male   White (not Hispan~ Placebo              128             87    88\n 2 P 2   male   Black (not Hispan~ Placebo              116             72    82\n 3 P 3   female White (not Hispan~ Verum                120             60    93\n 4 P 4   female Middle-Eastern, A~ Verum                130             76    82\n 5 P 5   male   Middle-Eastern, A~ Placebo              135             60   100\n 6 P 6   male   White (not Hispan~ Verum                148             85    85\n 7 P 7   male   White (not Hispan~ Verum                137             54    98\n 8 P 8   male   White (not Hispan~ Placebo              139             95    94\n 9 P 9   female White (not Hispan~ Placebo              154             71    83\n10 P 10  male   Hispanic           Verum                113             74    82\n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata %>% select(`sysRR (mmHg)`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 1\n   `sysRR (mmHg)`\n            <dbl>\n 1            128\n 2            116\n 3            120\n 4            130\n 5            135\n 6            148\n 7            137\n 8            139\n 9            154\n10            113\n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata %>% select(contains('r'),-contains('rr'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 2\n   Treatment    HR\n   <chr>     <dbl>\n 1 Placebo      88\n 2 Placebo      82\n 3 Verum        93\n 4 Verum        82\n 5 Placebo     100\n 6 Verum        85\n 7 Verum        98\n 8 Placebo      94\n 9 Placebo      83\n10 Verum        82\n# i 15 more rows\n```\n:::\n\n```{.r .cell-code}\nrawdata %>% pull(`sysRR (mmHg)`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 128 116 120 130 135 148 137 139 154 113 118 117 127 143 117 135 117 147 127\n[20] 130 136 141 150 147 130\n```\n:::\n:::\n\n\nExercise: Think of a cruet_stand / Gewürzmenage - define n_elements \\<- 5\\*10\\^3 - create a tibble \"menage\" with columns saltshaker, peppercaster and n_elements each for saltgrain and pepperflake - print saltshaker - print salt - print 100 saltgrains\n\n### List\n\nWhile matrix, data.frames, and tibbles always have the same number of rows for each column, sometimes different lengths are required. A list can handle all kinds of data with different number of elements for each sublist. This is a typical output format for statistical functions and is useful for collecting e.g. result tables or figures. Package rlist provides useful tools.\n\n#### Creation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshopping<-list(beverages=c('beer','water',\n                           'gin(not Gordons!!)','tonic'),\n               snacks=c('chips','pretzels'),\n               nonfood=c('DVDs','Akku'),\n               mengen=1:10,\n               volumen=rnorm(50,100,2))\nshopping\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$beverages\n[1] \"beer\"               \"water\"              \"gin(not Gordons!!)\"\n[4] \"tonic\"             \n\n$snacks\n[1] \"chips\"    \"pretzels\"\n\n$nonfood\n[1] \"DVDs\" \"Akku\"\n\n$mengen\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$volumen\n [1] 101.98092  99.72118 101.25978  99.50115  99.88413 103.65050 100.35412\n [8] 103.72203  97.45847  98.51527  98.86176 100.25617  99.18075 101.11364\n[15]  99.49699  99.67630  99.17729 100.27251 100.64437  98.00664  99.25581\n[22] 100.43009 100.20727 100.25817  98.48912  96.71237  96.46227 101.04724\n[29]  96.47107 100.85070  97.64126 100.82651 102.66924  98.58853  99.72314\n[36] 100.51849  98.90033 101.05662 100.26360  97.92360 100.89800  98.84879\n[43] 101.56033  98.08456 100.80067 101.36969  94.41230 100.80553  99.60254\n[50] 100.62478\n```\n:::\n\n```{.r .cell-code}\nshopping$snacks\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"chips\"    \"pretzels\"\n```\n:::\n:::\n\n\n#### Indexing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshopping[1]    #returns a list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$beverages\n[1] \"beer\"               \"water\"              \"gin(not Gordons!!)\"\n[4] \"tonic\"             \n```\n:::\n\n```{.r .cell-code}\nshopping[[1]]  #returns a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"beer\"               \"water\"              \"gin(not Gordons!!)\"\n[4] \"tonic\"             \n```\n:::\n\n```{.r .cell-code}\nstr(shopping[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ beverages: chr [1:4] \"beer\" \"water\" \"gin(not Gordons!!)\" \"tonic\"\n```\n:::\n\n```{.r .cell-code}\nstr(shopping[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:4] \"beer\" \"water\" \"gin(not Gordons!!)\" \"tonic\"\n```\n:::\n\n```{.r .cell-code}\nstr(shopping$beverages)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:4] \"beer\" \"water\" \"gin(not Gordons!!)\" \"tonic\"\n```\n:::\n\n```{.r .cell-code}\nshopping[1][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$<NA>\nNULL\n```\n:::\n\n```{.r .cell-code}\nshopping[[1]][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"water\"\n```\n:::\n\n```{.r .cell-code}\nshopping$beverages[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"water\"\n```\n:::\n\n```{.r .cell-code}\nt_out <- t.test(x = rnorm(n = 20,mean = 10,sd = 1),\n                y = rnorm(20,12,1))\nstr(t_out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 10\n $ statistic  : Named num -5.74\n  ..- attr(*, \"names\")= chr \"t\"\n $ parameter  : Named num 36.1\n  ..- attr(*, \"names\")= chr \"df\"\n $ p.value    : num 1.52e-06\n $ conf.int   : num [1:2] -2.35 -1.12\n  ..- attr(*, \"conf.level\")= num 0.95\n $ estimate   : Named num [1:2] 10.2 11.9\n  ..- attr(*, \"names\")= chr [1:2] \"mean of x\" \"mean of y\"\n $ null.value : Named num 0\n  ..- attr(*, \"names\")= chr \"difference in means\"\n $ stderr     : num 0.302\n $ alternative: chr \"two.sided\"\n $ method     : chr \"Welch Two Sample t-test\"\n $ data.name  : chr \"rnorm(n = 20, mean = 10, sd = 1) and rnorm(20, 12, 1)\"\n - attr(*, \"class\")= chr \"htest\"\n```\n:::\n\n```{.r .cell-code}\nt_out$p.value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.523729e-06\n```\n:::\n:::\n\n\n## Control structures\n\n### Loops\n\nRepetitive tasks like computation of descriptive statistics over many variables or repeated simulations of data can be declared inside of a loop. There are functions (like summarize(across(...))) that create those repetitions internally, but often doing this explicitly improves readability or helps solving various tasks like describing AND plotting data.\n\n#### for-loop\n\nIn a for-loop, we can define the number of runs in advance, e.g. by the number of variables to describe. There are 2 ways/styles, how to define this number:\n\n1.  by creating an index variable with an integer vector 1,2,3, ... number of runs/variables\n\n2.  by creating an index containing e.g. colnames\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# integer index\nprint('### Game of Loops ###')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"### Game of Loops ###\"\n```\n:::\n\n```{.r .cell-code}\nfor(season_i in 1:3) {\n  cat(paste('GoL Season',season_i,'\\n'))\n  for(episode_i in 1:5) {\n    cat(paste0('   GoL S.',season_i,\n                 ' Episode ',episode_i,'\\n'))\n  }\n  cat('\\n')\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGoL Season 1 \n   GoL S.1 Episode 1\n   GoL S.1 Episode 2\n   GoL S.1 Episode 3\n   GoL S.1 Episode 4\n   GoL S.1 Episode 5\n\nGoL Season 2 \n   GoL S.2 Episode 1\n   GoL S.2 Episode 2\n   GoL S.2 Episode 3\n   GoL S.2 Episode 4\n   GoL S.2 Episode 5\n\nGoL Season 3 \n   GoL S.3 Episode 1\n   GoL S.3 Episode 2\n   GoL S.3 Episode 3\n   GoL S.3 Episode 4\n   GoL S.3 Episode 5\n```\n:::\n\n```{.r .cell-code}\n# content index\n## names of elements\nfor(col_i in colnames(rawdata)){\n  print(col_i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"PatID\"\n[1] \"Sex\"\n[1] \"Ethnicity\"\n[1] \"Given name\"\n[1] \"Family name\"\n[1] \"Treatment\"\n[1] \"sysRR (mmHg)\"\n[1] \"diaRR (mmHg)\"\n[1] \"HR\"\n```\n:::\n\n```{.r .cell-code}\n## content of elements\nfor(col_i in shopping){\n  print(col_i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"beer\"               \"water\"              \"gin(not Gordons!!)\"\n[4] \"tonic\"             \n[1] \"chips\"    \"pretzels\"\n[1] \"DVDs\" \"Akku\"\n [1]  1  2  3  4  5  6  7  8  9 10\n [1] 101.98092  99.72118 101.25978  99.50115  99.88413 103.65050 100.35412\n [8] 103.72203  97.45847  98.51527  98.86176 100.25617  99.18075 101.11364\n[15]  99.49699  99.67630  99.17729 100.27251 100.64437  98.00664  99.25581\n[22] 100.43009 100.20727 100.25817  98.48912  96.71237  96.46227 101.04724\n[29]  96.47107 100.85070  97.64126 100.82651 102.66924  98.58853  99.72314\n[36] 100.51849  98.90033 101.05662 100.26360  97.92360 100.89800  98.84879\n[43] 101.56033  98.08456 100.80067 101.36969  94.41230 100.80553  99.60254\n[50] 100.62478\n```\n:::\n\n```{.r .cell-code}\n# automatic creation of integer index from elements\nfor(col_i in seq_along(colnames(rawdata))){\n  print(colnames(rawdata)[col_i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"PatID\"\n[1] \"Sex\"\n[1] \"Ethnicity\"\n[1] \"Given name\"\n[1] \"Family name\"\n[1] \"Treatment\"\n[1] \"sysRR (mmHg)\"\n[1] \"diaRR (mmHg)\"\n[1] \"HR\"\n```\n:::\n\n```{.r .cell-code}\n# edge-case of 0 elements -> 0 runs\nfor(col_i in seq_len(0)){\n  print(colnames(rawdata)[col_i])\n}\n```\n:::\n\n\n#### while-loops\n\nIf not number of repetitions is know, but a condition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest <- 0\nwhile(test<10){\n  print(test)\n  test   <- test + 1 #test <- test+1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n```\n:::\n:::\n\n\n### Conditions\n\n#### if else\n\nWe can run code if condition(s) are true:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex<-'male'\nif (sex=='male')  {\n  print('Male')\n} else {\n  print('Female')\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Male\"\n```\n:::\n\n```{.r .cell-code}\nif (sex=='male')  {\n  print('Male')\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Male\"\n```\n:::\n\n```{.r .cell-code}\nif (sex!='male'){\n  print('Female')\n}\nTRUE&FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n(1>10)&(1<5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nTRUE|FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n(1>10)|(1<5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n#### ifelse\n\nWe can get text conditionally:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(ifelse(test = sex=='male',\n             yes = 'is male',\n             no = 'is female'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"is male\"\n```\n:::\n\n```{.r .cell-code}\np <- .0012\npaste0('That is ',\n       ifelse(test = p<=.05,yes = '',no = 'not '),\n       'significant')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"That is significant\"\n```\n:::\n\n```{.r .cell-code}\ntestvar <- 3\nif(testvar %in% c(1,3,5)){\n  print('uneven')\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"uneven\"\n```\n:::\n:::\n\n\n#### case_when / case_match\n\nWhen there are many tests to do, case_when or case_match are nice replacements for ifelse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(rawdata,\n       Hypertension=case_when(\n         `sysRR (mmHg)`<120 & `diaRR (mmHg)`<70 ~ \"normotensive\",\n         `sysRR (mmHg)`<160 & `diaRR (mmHg)`<=80 ~ \"borderline\",\n         .default = \"hypertensive\")) |> \n  select(contains(\"RR\"),Hypertension)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 3\n   `sysRR (mmHg)` `diaRR (mmHg)` Hypertension\n            <dbl>          <dbl> <chr>       \n 1            128             87 hypertensive\n 2            116             72 borderline  \n 3            120             60 borderline  \n 4            130             76 borderline  \n 5            135             60 borderline  \n 6            148             85 hypertensive\n 7            137             54 borderline  \n 8            139             95 hypertensive\n 9            154             71 borderline  \n10            113             74 borderline  \n# i 15 more rows\n```\n:::\n:::\n",
    "supporting": [
      "R101_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}