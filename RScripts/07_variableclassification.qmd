# Grouping of variables by type / distribution / use

```{r}
pacman::p_load(conflicted,wrappedtools,tidyverse, here)
conflicts_prefer(dplyr::filter)
rawdata <- readRDS(here('data/rawdata.rds'))
```

## Test for Normal distribution

### Testing a single variable

Before computing some test-statistics, a graphical exploration should be done by e.g. density plots.

There are a number of tests for Normal distribution, all testing the Null hypothesis of data coming from a population with Normal distribution. So small p-values lead to rejection of the Null and indicate deviation from normality. Kolmogorov-Smirnov-test (for larger sample sizes) and Shapiro-Wilk-test (for smaller samples) will be used as examples.

Other tests would be e.g. Anderson-Darling, and the Cramer-von Mises test, see package `nortest`.

```{r}
ks.test(x = rawdata$`Size (cm)`,
        "pnorm",
        mean=mean(rawdata$`Size (cm)`, 
                  na.rm = TRUE),
        sd=sd(rawdata$`Size (cm)`, 
              na.rm = TRUE))

ksnormal(rawdata$`Size (cm)`,lillie = FALSE)
shapiro.test(rawdata$`Size (cm)`)

ggplot(rawdata,aes(x = `Size (cm)`))+
  geom_density(fill="pink")
ggplot(rawdata,aes(x = `Size (cm)`,fill=Sex))+
  geom_density(alpha=.4)
```

If severe group difference can be expected (case/control, sex ...), exploration and analyses should be done in subgroups.

```{r}
rawdata |> filter(Sex=="m") |> 
  pull(`Size (cm)`) |> 
  ksnormal()
rawdata |> 
  group_by(Sex) |>
  summarize(
    n=n(),
    p_KS = ksnormal(`Size (cm)`,lillie = FALSE),
    `pGauss (Shapiro)` = shapiro.test(`Size (cm)`) |> 
      pluck("p.value"))
```

### Testing several variables

To explore larger data sets, it may be useful to test all numerical variables for normality, this can be done in a loop or with the across-function. As a start for the loop-solution we can get the names and positions for all (or selected) numerical variables with the ColSeeker-function from wrappedtools.

```{r}
numvars <- 
  ColSeeker(data = rawdata,  # can be omitted, as it is the default 
            varclass = "numeric")
numvars$index
head(numvars$names)
numvars$count
```

Loops can be created with either a numeric counter-like index or content-based index.

Loop Version 1:

```{r}
## result table v1, pre-filled
resulttable1 <- tibble(
  Variables=numvars$names,
  pKS=NA_real_,
  pSh=NA_real_
)
## loop version 1
for(var_i in seq_len(numvars$count)){
  resulttable1$pKS[var_i] <-
    ksnormal(rawdata[[numvars$names[var_i]]])
  resulttable1$pSh[var_i] <- 
    shapiro.test(rawdata |> 
                   pull(numvars$names[var_i]))$p.value
}
head(resulttable1)
resulttable1 |> 
  mutate(pKS=formatP(pKS,ndigits=5),
         pSh=formatP(pSh,mark = T))
```

Loop Version 2:

```{r}
## result table v2, just structure
resulttable2 <- tibble(Measures=NA_character_,
                       pKS_Placebo=NA_character_,
                       pKS_Verum=NA_character_,
                       .rows = 0)
for(var_i in numvars$names){
  ks_tmp <- by(data = rawdata[[var_i]], 
               INDICES=rawdata$Testmedication,
               FUN=ksnormal,
               lillie=FALSE)
  resulttable2 <-add_row(resulttable2,   
                         Measures=var_i,
                         pKS_Placebo=ks_tmp[[1]] |> 
                           formatP(), # added rounding/formatting
                         pKS_Verum=ks_tmp[[2]] |> 
                           formatP())
}
head(resulttable2)
```

across() - Version:

`across()` in R (from `dplyr`) is a powerful tool that lets you apply the same operation to multiple columns in your data frame, similar to using loops or list comprehensions with Pandas DataFrames in Python. `across()` (sort of) loops over variables / columns and applies function(s), it can be used inside summarize, mutate, filter.

```{r}
resulttable1a <- 
   rawdata |> 
  summarize(across(.cols=all_of(numvars$names[-(1:4)]),
                   .fns = list(
                     pKS=~ksnormal(.x) |> 
                       formatP(mark = TRUE),
                     pSh=~shapiro.test(.x) |> 
                       pluck("p.value") |> 
                       formatP(mark = TRUE)))) |> 
  #change output structure to long form
  pivot_longer(everything(),
               names_to=c("Variable",".value"), 
               names_sep = "_")  
# pivot_longer(everything(),
  #              names_to=c("Variable","test"), #.variable
  #              names_sep = "_") |> 
  # pivot_wider(names_from=test, values_from=value)
head(resulttable1a)
head(resulttable1)

 resulttable2a <- 
   rawdata |> 
   mutate(Testmedication=factor(Testmedication,
                                levels=c(0,1),
                                labels=c('Placebo','Verum'))) |>
   # mutate(Testmedication=case_match(Testmedication,
   #                                  0~"Placebo",
   #                                  1~"Verum")) |> 
   group_by(Testmedication) |>
   summarize(across(all_of(numvars$names[-(1:4)]),
                    .fns = ~ksnormal(.x) |> 
                      formatP(mark = TRUE))) |> 
   pivot_longer(-Testmedication,
                names_to="Measure") |> 
   pivot_wider(names_from=Testmedication,
               values_from=value)
 head(resulttable2a)
 head(resulttable2)

resulttable3 <- 
  rawdata |> 
  group_by(Testmedication) |>
  summarize(across(all_of(numvars$names[-(1:4)]),
                   .fns = list(
                     Mean=~mean(.x, na.rm=TRUE) |> 
                       roundR(5),
                     Median=~median(.x, na.rm=TRUE) |> 
                       roundR(5),
                     pKS=~ksnormal(.x) |> 
                       formatP(mark = TRUE),
                     pSh=~shapiro.test(.x) |> 
                       pluck("p.value") |> 
                       formatP(mark = TRUE)))) |> 
  pivot_longer(-Testmedication,
               names_to=c("Variable","test"), #Variable,.value
               names_sep = "_") |> 
  pivot_wider(names_from=test, values_from=value) |> 
  arrange(Variable)
head(resulttable3)

rm(numvars)
```

## Exercise: Distribution of penguin measures

-   Using the penguin data, testing for which numerical measures a test for a ***gaussian*** distribution is meaningful

-   For those measures, test Normality in the total sample as well as for subgroups defined by species and sex

    1.  single measure, all penguins, plot and test

    2.  single measure, by species/sex, plot and test

    3.  all measures within species, plot and test

    4.  all measures within species and sex, plot and test

## Picking column names and positions

Based on data inspection, testing, and background knowledge, variables can be sorted into scale levels:

```{r}
gaussvars <- ColSeeker(
  data = rawdata,   # can be omitted, as it is the default
  namepattern = c("si","we","BMI","BP","mri"),
  casesensitive = FALSE)

ordvars <- ColSeeker(data = rawdata, 
                     namepattern = c("Age","Lab"))

factvars <- ColSeeker(data = rawdata,
                      namepattern = c("Sex","med","NYHA"),
                      returnclass = TRUE)

rawdata <- mutate(rawdata,
                  across(all_of(factvars$names),
                         ~factor(.x)))
```

To make data accessible for other scripts, data can be saved:

```{r}
save(rawdata,list = ls(pattern = "vars"),
     file = here("data/bookdata1.RData"))
```
